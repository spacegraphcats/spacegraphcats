{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Explore large, annoying graphs using hierarchies of dominating sets - because in space, no one can hear you miao!</p> <p>This is a collaboration between the Theory In Practice lab at University of Utah, the Lab for Data Intensive Biology at UC Davis, and Dr. Felix Reidl at Birkbeck University of London.  Initial development of spacegraphcats was generously supported by the Moore Foundation's Data Driven Discovery Initiative.</p> <p></p>"},{"location":"#citation-information","title":"Citation information","text":"<p>See the Genome Biology publication Exploring neighborhoods in large metagenome assembly graphs using spacegraphcats reveals hidden sequence diversity, Brown et al., 2020, doi: https://doi.org/10.1186/s13059-020-02066-4.</p>"},{"location":"00-installing-spacegraphcats/","title":"spacegraphcats: installation","text":""},{"location":"00-installing-spacegraphcats/#step-i-install-the-dependencies","title":"Step I: install the dependencies.","text":"<p>spacegraphcats relies on several dependencies - Python, a C/C++ environment, and bcalm 2, in particular.</p> <p>There are several ways to install these dependencies. We recommend using conda, but include instructions for using a Python virtual environment or a blank Ubuntu machine as well.</p>"},{"location":"00-installing-spacegraphcats/#1-installing-dependencies-using-conda","title":"1. Installing dependencies using conda","text":"<p>If you have conda installed, you can use packages from conda-forge and bioconda to install all the dependencies for spacegraphcats.</p> <p>Start by cloning the spacegraphcats repository:</p> <pre><code>git clone https://github.com/spacegraphcats/spacegraphcats/\n</code></pre> <p>Now, create a new 'sgc' environment with the necessary packages packages:</p> <pre><code>conda env create -f spacegraphcats/environment.yml -n sgc\n</code></pre> <p>Once it's created, activate the environment you just created:</p> <pre><code>conda activate sgc\n</code></pre> <p>and install spacegraphcats from the development directory:</p> <pre><code>pip install -e ./spacegraphcats/\n</code></pre> <p>and voila, done!</p>"},{"location":"00-installing-spacegraphcats/#2-installing-dependencies-in-a-virtual-environment","title":"2. Installing dependencies in a virtual environment","text":"<p>If you already have a functioning Python &gt;= 3.8 along with a C/C++ development environment, you can install the dependencies in a venv.</p> <p>Install virtualenv if you have not done so:</p> <pre><code>pip install virtualenv\n</code></pre> <p>Change to a working directory, and create a virtualenv:</p> <pre><code>python -m virtualenv -p python3.8 catsenv\n</code></pre> <p>Activate the virtualenv, upgrade pip, and install Cython:</p> <pre><code>. catsenv/bin/activate\npip install -U setuptools pip\npip install Cython\n</code></pre> <p>Note: You will also need to install bcalm 2; please following their install instructions.</p> <p>Once you have the basic dependencies, go ahead and clone spacegraphcats:</p> <pre><code>git clone https://github.com/spacegraphcats/spacegraphcats/\n</code></pre> <p>and install the requirements:</p> <pre><code>cd spacegraphcats\npip install -r requirements.txt\n</code></pre> <p>This will take a few minutes.</p> <p>Finally, install the git repo in developer mode:</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"00-installing-spacegraphcats/#3-installing-dependencies-on-a-blank-ubuntu-machine","title":"3. Installing dependencies on a blank Ubuntu machine","text":"<p>If you're starting e.g. on a blank AWS instance such as ubuntu/images/hvm-ssd/ubuntu-xenial-16.04-amd64-server-20180126 (ami-79873901), you'll need to make sure you have Python 3, a dev environment, and other stuff:</p> <pre><code>sudo apt-get update\nsudo apt-get -y install python3 python3-dev zlib1g-dev g++ \\\n    python3-venv make cmake\n</code></pre> <p>Now create a virtualenv named catsenv and activate it; then upgrade and install a few things.</p> <pre><code>python3 -m venv catsenv\n. catsenv/bin/activate\npip install -U setuptools pip\npip install Cython\n</code></pre> <p>Note: You will also need to install bcalm 2; please following their install instructions.</p> <p>Once you have the basic dependencies, go ahead and clone spacegraphcats:</p> <pre><code>git clone https://github.com/spacegraphcats/spacegraphcats/\n</code></pre> <p>and install the requirements:</p> <pre><code>cd spacegraphcats\npip install -r requirements.txt\n</code></pre> <p>This will take a few minutes.</p> <p>Finally, install the git repo in developer mode:</p> <pre><code>pip install -e ./spacegraphcats/\n</code></pre>"},{"location":"00-installing-spacegraphcats/#step-ii-test-spacegraphcats-by-running-a-small-test-dory","title":"Step II: Test spacegraphcats by running a small test: dory.","text":"<p>In the <code>spacegraphcats/</code> top level directory (containing e.g. <code>README.md</code>), run:</p> <pre><code>pip install -e .\n</code></pre> <p>This installs the spacegraphcats project in developer mode, so that the installed package points at this directory and changes in this directory are available in the virtual environment.</p> <pre><code>python -m spacegraphcats run dory-test search\n</code></pre> <p>This should run in a few seconds, and you should see something like this in the output:</p> <pre><code>...\n=&gt; containment: 0.0%\n[Fri Aug 14 07:53:04 2020]\nFinished job 0.\n4 of 4 steps (100%) done\nComplete log: /Users/t/dev/spacegraphcats/.snakemake/log/2020-08-14T075302.093387.snakemake.log\n\n-------- DONE --------\n\ncatlas output directory: dory_k21_r1\nsearch output directory: dory_k21_r1_search_oh0\n</code></pre> <p>You will have a bunch of new output files:</p> <ul> <li>the <code>dory_k21/</code> directory contains the BCALM assembly of the input files into a compact De Bruijn graph; the key file here is <code>dory_k21/bcalm.unitigs.db</code>. There is also an output log file, <code>bcalm.log.txt</code>, that contains the console output of BCALM's run.</li> <li>the <code>dory_k21_r1/</code> directory contains the various files of the catlas constructed by spacegraphcats:<ul> <li>cdbg.gxt</li> <li>contigs.fa.gz</li> <li>contigs.fa.gz.indices</li> <li>contigs.fa.gz.info.csv</li> <li>contigs.fa.gz.mphf</li> <li>first_doms.txt</li> <li>catlas.csv</li> <li>commands.log</li> </ul> </li> <li>the <code>dory_k21_r1_search_oh0/</code> directory contains the output of a search:<ul> <li>results.csv</li> <li>dory-head.fa.cdbg_ids.txt.gz</li> <li>dory-head.fa.contigs.sig</li> <li>dory-head.fa.frontier.txt.gz</li> <li>dory-head.fa.response.txt</li> <li>command.txt</li> </ul> </li> </ul>"},{"location":"00-installing-spacegraphcats/#step-iii-run-a-bigger-test-twofoo","title":"Step III: Run a bigger test: twofoo.","text":"<p>Now let's check the full pipeline for a synthetic mixture of two genomes (Akkermansia and Shewanella baltica OS 223) from the Shakya et al., 2014, benchmark study.</p> <p>To run this, you'll first need to download and prepare the input file, <code>twofoo.fq.gz</code>:</p> <pre><code>make twofoo.fq.gz\n</code></pre> <p>which will take a few minutes.</p> <p>Then, run:</p> <pre><code>python -m spacegraphcats run twofoo search\n</code></pre> <p>which will generate searches of the twofoo synthetic data set with <code>data/2.fa.gz</code>, <code>data/47.fa.gz</code>, and <code>data/63.fa.gz</code>.</p> <p>It should take about 5 minutes on a relatively recent laptop, and will require ~1 GB of RAM.</p> <p>If this succeeds, your install is all good - give yourself a high five! you've made it!</p> <p>See running spacegraphcats for next steps and more information on config files.</p>"},{"location":"01-running-spacegraphcats/","title":"spacegraphcats: a run guide","text":""},{"location":"01-running-spacegraphcats/#installing-the-spacegraphcats-software-and-its-dependencies","title":"Installing the spacegraphcats software and its dependencies","text":"<p>Please see Installing spacegraphcats.</p>"},{"location":"01-running-spacegraphcats/#running-spacegraphcats-search-output-files","title":"Running spacegraphcats search &amp; output files","text":"<pre><code>python -m spacegraphcats run dory-test search\n</code></pre> <p>This should run in a few seconds, and you should see something like this in the output:</p> <pre><code>...\nquery inclusion by retrieved contigs: 100.000%\nquery similarity to retrieved contigs: 100.000%\ntotal time: 0.0s\nFinished job 0.\n6 of 6 steps (100%) done\n</code></pre> <p>You will have a bunch of new output files:</p> <ul> <li>the <code>dory_k21/</code> directory contains the BCALM assembly of the input files into a compact De Bruijn graph; the key file here is <code>dory_k21/bcalm.unitigs.db</code>. There is also an output log file, <code>bcalm.log.txt</code>, that contains the console output of BCALM's run.</li> <li>the <code>dory_k21_r1/</code> directory contains the various files of the catlas constructed by spacegraphcats:<ul> <li>cdbg.gxt - the cDBG connection graph, in a custom format; produced by <code>bcalm_to_gxt.py</code></li> <li>contigs.info.csv - summary information about the cDBG unitigs; produced by <code>bcalm_to_gxt.py</code></li> <li>contigs.indices - a numpy savez file containing mapping arrays; produced by <code>index_contigs_by_kmer.py</code></li> <li>contigs.mphf - Minimal Perfect Hash Function parameters for all of the k-mers in the cDBG; produced by <code>index_contigs_by_kmer.py</code></li> <li>contigs.sig - sourmash signature for cDBG nodes. Defaults to scaled = 1000.</li> <li>contigs.sizes - sizes of all cDBG nodes in pickle format; produced by <code>index_cdbg_by_kmer.py</code></li> <li>first_doms.txt - the dominating set information for the cDBG; produced by <code>spacegraphcats/catlas/catlas.py</code></li> <li>catlas.csv - the catlas for the cDBG; produced by <code>spacegraphcats/catlas/catlas.py</code></li> <li>commands.log - a partial log of all of the commands</li> </ul> </li> <li>the <code>dory_k21_r1_search_oh0/</code> directory contains the output of a search:<ul> <li>results.csv - summary results for the queries (containment, similarity, etc.)</li> <li>dory-head.fa.cdbg_ids.txt.gz - cDBG node IDs (unitig IDs) matching query</li> <li>dory-head.fa.cdbg_ids.reads.gz - if <code>extract_reads</code> is used, reads from the original sequencing file that contain k-mers in the query neighborhood contigs. Reads will be output in the same format as the input data, e.g. in FASTQ if the original data was FASTQ, or FASTA if the original data was FASTA.</li> <li>dory-head.fa.contigs.sig - the sourmash signature of the entire match in the cDBG</li> <li>dory-head.fa.frontier.txt.gz - catlas node IDs matching query</li> <li>dory-head.fa.response.txt - response curve showing how much overhead is gained for each node</li> <li>command.txt - a partial log of the commands run</li> </ul> </li> </ul> <p>The <code>results.csv</code> file contains the following information:</p> <ul> <li><code>query</code>:  the file path to the query used by spacegraphcats </li> <li><code>containment</code>: the containment of the query in the retrieved neighborhood</li> <li><code>similarity</code>: the similarity of the query to the retrieved neighborhood</li> <li><code>bp</code>: the number of basepairs in the neighborhood</li> <li><code>contigs</code>: the number of unitigs contained in the query from the cDBG</li> <li><code>ksize</code>: the k-mer size used to perform the query</li> <li><code>num_query_kmers</code>: the number of k-mers in the query </li> <li><code>best_containment</code>: tbd</li> <li><code>cdbg_min_overhead</code>: tbd</li> <li><code>catlas_min_overhead</code>: tbd</li> </ul> <p>Note that:</p> <ul> <li>if the query Q is entirely in the indexed metagenome M, then 1/similarity is the relative neighborhood size, because |Q intersect M| is |Q|, and |Q union M| is |M|, so 1/similarity is |M|/|Q|. This does not hold if the query is not entirely within the indexed metagenome.</li> <li><code>num_query_kmers</code> is |Q|, not |Q intersect M|</li> </ul>"},{"location":"01-running-spacegraphcats/#configuring-and-running-spacegraphcats-itself","title":"Configuring and running spacegraphcats itself","text":"<p>There are three important top-level files.</p> <ol> <li> <p>The script <code>python -m spacegraphcats</code> uses snakemake to run the pipeline.</p> </li> <li> <p>The Snakefile itself is under <code>conf/Snakefile</code>, and is not intended to be particularly human readable :). The snakemake run is configured by a YAML config file.</p> </li> <li> <p>The configuration files are relatively simple, and are (by convention) contained in the <code>conf/</code> directory, although you can put them elsewhere. The filenames should end in either <code>.yaml</code> or <code>.conf</code>.</p> </li> </ol> <p>To run spacegraphcats on a new data set, you will need to write a new config file. An empty template is available as <code>spacegraphcats/conf/empty.yaml</code>, and you can display the empty config file with <code>python -m spacegraphcats showconf empty</code>.</p>"},{"location":"01-running-spacegraphcats/#config-files-the-dory-example","title":"Config files: the <code>dory</code> example","text":"<p>Config files look like this:</p> <pre><code>catlas_base: dory\ninput_sequences:\n- data/dory-subset.fq\nkeep_graph_pendants: true\npaired_reads: false\nksize: 21\nradius: 1\nsearch:\n- data/dory-head.fa\n</code></pre> <p>Here, the <code>catlas_base</code>, <code>ksize</code>, and <code>radius</code> are used to name output directories - hence <code>dory/</code> and <code>dory_k21_r1/</code>, above. <code>catlas_base</code> is arbitrary, <code>ksize</code> is the k-mer size (we suggest 21 or 31), and <code>radius</code> is the domset radius (we suggest 1).</p> <p>The <code>input_sequences</code> contains the set of input files (FASTA or FASTQ, potentially gzipped) to use to build the compact De Bruijn graph. Note, these should be k-mer-error-trimmed, or otherwise you will have very big cDBGs... see the error trimming information from Brown et al. for an example. Note that the <code>trim-low-abund.py</code> command is in the khmer package, which is a requirement for spacegraphcats, so you will already have it installed.</p> <p>The <code>search</code> entry specifies the query files that you are using to search the catlas.</p> <p>So, in brief, this config file:</p> <ul> <li>builds a catlas with k=21 and r=1 from <code>data/dory-subset.fa</code>;</li> <li>searches with <code>data/dory-head.fa</code> when you call <code>search</code>.</li> </ul>"},{"location":"01-running-spacegraphcats/#a-larger-example-twofoo","title":"A larger example: <code>twofoo</code>","text":"<p>Here you can see another config file, for a synthetic mixture of two genomes (Akkermansia and Shewanella baltica OS 223) from the Shakya et al., 2014, benchmark study:</p> <pre><code>catlas_base: twofoo\ninput_sequences:\n- twofoo.fq.gz\nksize: 31\nradius: 1\nsearch:\n- data/2.fa.gz\n- data/47.fa.gz\n- data/63.fa.gz\n</code></pre> <p>To run this, you'll first need to download and prepare the input file, <code>twofoo.fq.gz</code>:</p> <pre><code>make twofoo.fq.gz\n</code></pre> <p>which will take a few minutes.</p> <p>Then, run:</p> <pre><code>python -m spacegraphcats run twofoo search\n</code></pre> <p>which will generate searches of the twofoo synthetic data set with <code>data/2.fa.gz</code>, <code>data/47.fa.gz</code>, and <code>data/63.fa.gz</code>.</p> <p>It should take about 5 minutes on a relatively recent laptop, and will require ~1 GB of RAM.</p>"},{"location":"01-running-spacegraphcats/#interpreting-the-results-of-a-run","title":"Interpreting the results of a run","text":"<p>Start up a Jupyter notebook, and run this in a cell:</p> <pre><code>%matplotlib inline\nimport pandas\nfrom matplotlib import pyplot\n\nresults = pandas.read_csv('twofoo_k31_r1_search_oh0/results.csv')\n\nfig, axes = pyplot.subplots(nrows=1, ncols=2, figsize=(6, 3))\naxes[0].violinplot(results.similarity)\naxes[1].violinplot(results.containment)\n\naxes[0].axis(ymin=0.0)\naxes[0].axis(ymax=1.0)\n\naxes[0].get_xaxis().set_ticks([])\naxes[1].get_xaxis().set_ticks([])\naxes[1].get_yaxis().set_ticks([])\n\n\naxes[0].set_xlabel('similarity')\naxes[1].set_xlabel('containment')\n</code></pre> <p>This will plot the distribution of similarity and containment in the results.</p>"},{"location":"01-running-spacegraphcats/#extracting-the-sequences-that-match-search-results","title":"Extracting the sequences that match search results","text":"<p>You can get the cDBG unitigs for the searches, and the reads corresponding to them, by using the targets <code>extract_reads</code> and <code>extract_contigs</code>.</p> <pre><code>python -m spacegraphcats run twofoo extract_contigs extract_reads\n</code></pre> <p>This will produce the files:</p> <pre><code>twofoo_k31_r1_search_oh0/2.fa.gz.cdbg_ids.contigs.fa.gz\ntwofoo_k31_r1_search_oh0/47.fa.gz.cdbg_ids.contigs.fa.gz\ntwofoo_k31_r1_search_oh0/63.fa.gz.cdbg_ids.contigs.fa.gz\n\ntwofoo_k31_r1_search_oh0/2.fa.gz.cdbg_ids.reads.gz\ntwofoo_k31_r1_search_oh0/47.fa.gz.cdbg_ids.reads.gz\ntwofoo_k31_r1_search_oh0/63.fa.gz.cdbg_ids.reads.gz\n</code></pre> <p>which are (respectively) the contigs for the neighborhoods around each query, and the reads for the neighborhoods around each query.</p>"},{"location":"01-running-spacegraphcats/#other-information","title":"Other information","text":""},{"location":"01-running-spacegraphcats/#the-spacegraphcats-script","title":"The <code>spacegraphcats</code> script","text":"<p>The <code>spacegraphcats</code> script has several targets, in addition to <code>search</code>.</p> <ul> <li><code>python -m spacegraphcats run twofoo build</code> will build the catlas</li> <li><code>python -m spacegraphcats run twofoo clean</code> should remove the build targets.</li> <li><code>python -m spacegraphcats run twofoo extract_contigs</code> -- get contigs for search results; see above.</li> <li><code>python -m spacegraphcats run twofoo extract_reads</code> -- get reads for search results; see above.</li> </ul> <p>You can also specify <code>--radius &lt;n&gt;</code> to override the radius defined in the YAML config file and <code>--experiment foo</code> to append a <code>_foo</code> to the search directory.)</p> <p>Last, but not least: snakemake locks the directory to make sure processes don't step on each other. This is important when catlases need to be built (you don't want two different <code>search</code> commands stepping on each other during the catlas building phase) but once you have built catlases you can do searches in parallel.  To enable this add <code>--nolock</code> to the run command. </p>"},{"location":"01-running-spacegraphcats/#characterizing-the-catlas","title":"Characterizing the catlas","text":"<p>(The below may not be working. - CTB 7/22/2018.)</p>"},{"location":"01-running-spacegraphcats/#extracting-high-articulated-bits-of-the-cdbg","title":"Extracting high articulated bits of the cDBG","text":"<p>First, build the twofoo data set with r5:</p> <pre><code>python -m spacegraphcats run twofoo build --radius=5\n</code></pre> <p>Then, extract nodes with many cDBG nodes and few k-mers (by ratio):</p> <pre><code>python -m spacegraphcats.search.extract_nodes_by_shadow_ratio twofoo_k31_r5 zzz.fq\n</code></pre> <p>Now, look at the content of the extracted nodes -- the presence of the Akkermansia genome is essentially nil, because there is no strain variation in this part of the graph / the assembly is quite good:</p> <pre><code>sourmash search --containment zzz.fq.sig data/2-akker.sig --threshold=0\n</code></pre> <p>should yield</p> <pre><code>similarity   match\n----------   -----\n  0.2%       CP001071.1 Akkermansia muciniphila ATCC BAA-835, complete...\n</code></pre> <p>while the two Shewanella genomes interfere with each other, creating a highly articulated cDBG that leads to poor assembly.  Thus the command above extracts the Shewanella bits of the catlas preferentially; so</p> <pre><code>sourmash search --containment zzz.fq.sig data/47-os185.sig --threshold=0\n</code></pre> <p>should yield</p> <pre><code>similarity   match\n----------   -----\n 54.1%       NC_009665.1 Shewanella baltica OS185, complete genome\n</code></pre> <p>and</p> <pre><code>sourmash search --containment zzz.fq.sig data/63-os223.sig --threshold=0\n</code></pre> <p>should yield</p> <pre><code>similarity   match\n----------   -----\n 59.1%       NC_011663.1 Shewanella baltica OS223, complete genome\n</code></pre>"},{"location":"02-spacegraphcats-use-cases/","title":"spacegraphcats: use cases and working with the output","text":""},{"location":"02-spacegraphcats-use-cases/#installing-the-spacegraphcats-software-and-its-dependencies","title":"Installing the spacegraphcats software and its dependencies","text":"<p>Please see Installing spacegraphcats.</p>"},{"location":"02-spacegraphcats-use-cases/#spacegraphcats-use-cases","title":"Spacegraphcats use cases","text":""},{"location":"02-spacegraphcats-use-cases/#metagenome-bin-completion","title":"Metagenome bin completion","text":"<p>As discussed in the primer on metagenomics and assembly graphs, assembly and binning are lossy processes that leave many reads uncharacterized in metagenome analysis.  Spacegraphcats can be used to recover unassembled and unbinned reads that \"belong\" to a metagenome bin by using the metagenome bin as a query.  We recommend using the Atlas automated metagenome analysis pipeline to produce the initial bins.  (Alternatively, the genome-grist pipeline may be used to identify the list of known reference genomes to be used as queries for a metagenome.) Then, each bin can be used as a query, producing a query neighborhood that reassociates unassembled and unbinned reads that are graph-adjacent to the query. In a metagenome from an oil reservoir, bin completion with spacegraphcats identified strain-variable regions in genes that were present in the bin (e.g. gyrA in panel A of the figure below) and identified unbinned genes that augmented the functional content of the metagenome by 13% (panel B of the figure below).</p> <p> Source: Brown et al. 2020</p> <p>Install companion software:</p> <pre><code>conda install sourmash fastp khmer\n</code></pre> <p>Download data:</p> <pre><code>wget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR197/008/SRR1976948/SRR1976948_1.fastq.gz\nwget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR197/008/SRR1976948/SRR1976948_2.fastq.gz\n</code></pre> <p>Adapter trim the data:</p> <pre><code>fastp --in1 SRR1976948_1.fastq.gz \\\n  --in2 SRR1976948_2.fastq.gz \\\n  --out1 SRR1976948_1.trim.fastq.gz \\\n  --out2 SRR1976948_2.trim.fastq.gz \\\n  --detect_adapter_for_pe \\\n  --qualified_quality_phred 4 \\\n  --length_required 31 --correction \\\n  --json SRR1976948.trim.json \\\n  --html SRR1976948.trim.html\n</code></pre> <p>k-mer trim the data:</p> <pre><code>interleave-reads.py SRR1976948_1.trim.fastq.gz SRR1976948_2.trim.fastq.gz | \\\n        trim-low-abund.py --gzip -C 3 -Z 18 -M 20e9 -V - -o SRR1976948.abundtrim.fq.gz\n</code></pre> <p>Download the query genome (this is a metagenome bin produced from SRR1976948):</p> <pre><code>wget ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCA/001/508/995/GCA_001508995.1_ASM150899v1/GCA_001508995.1_ASM150899v1_genomic.fna.gz\n</code></pre> <p>Configuration file, saved as <code>conf1.yml</code>. Note that configuration files may contain multiple input sequences from which to build the cDBG and catlas, or multiple search fasta files. </p> <pre><code>catlas_base: 'SRR1976948'\ninput_sequences:\n- SRR1976948.abundtrim.fq.gz\nksize: 31\nradius: 1\nsearch:\n- GCA_001508995.1_ASM150899v1_genomic.fna.gz\n</code></pre> <p>run spacegraphcats:</p> <pre><code>python -m spacegraphcats run conf1.yml extract_contigs extract_reads --nolock \n</code></pre> <p>compare the output sequences:</p> <pre><code>sourmash compute -k 21,31,51 --scaled 2000 -o GCA_001508995.1_ASM150899v1_genomic.sig GCA_001508995.1_ASM150899v1_genomic.fna.gz\nsourmash compare -k 31 --csv comp.csv *sig SRR1976948_k31_r1_search_oh0/*sig\n</code></pre> <p>Publications using this approach are listed below:</p> <ol> <li>Brown, C.T., Moritz, D., O\u2019Brien, M.P. et al. Exploring neighborhoods in large metagenome assembly graphs using spacegraphcats reveals hidden sequence diversity. Genome Biol 21, 164 (2020). https://doi.org/10.1186/s13059-020-02066-4</li> <li>Lumian, J.E., Jungblut, A.D., Dillion, M.L. et al. Metabolic Capacity of the Antarctic Cyanobacterium Phormidium pseudopriestleyi That Sustains Oxygenic Photosynthesis in the Presence of Hydrogen Sulfide. Genes 12, 426 (2021). https://doi.org/10.3390/genes12030426 </li> </ol>"},{"location":"02-spacegraphcats-use-cases/#identifying-the-context-of-eg-horizontally-transferred-genes","title":"Identifying the context of e.g. horizontally transferred genes","text":"<p>Spacegraphcats queries don't need to be an entire genome, but can be any size (greater than k).  For example, one can query with a gene of interest.  In the example below, we identify antibiotic resistance genes in time series human stool metagenomes using GROOT, and then use the identified genes as spacegraphcats queries. Using this method, we can see how the context of antibiotic resistance genes changes over time.</p> <p>The dataset used below is a time series from a single individual with Crohn's disease, sequenced by the Integrative Human Microbiome Project (iHMP). The stool microbiome from this individual was sequenced at 12 different timepoints over 37 weeks, and the individual was on antibiotics at various times during the that timeframe.</p> <p> Times of sequencing and antibiotic exposure for individual H4017 from the Integrative Human Microbiome Project.</p> <p>We'll determine the sequence context of one antibiotic resistance gene in one sample using one radius. </p> <p>Install companion software needed for this analysis:</p> <pre><code>conda install 'sourmash&gt;=4.1.0,&lt;5' fastp=0.20.1 bbmap=38.70 khmer=3.0.0a3 groot=1.1.2 samtools=1.12 bandage=0.8.1 blast=2.11.0\n</code></pre> <p>Then, download the the sequencing data and perform quality control. This sample was taken at week 25 when the individual was on antibiotics.</p> <pre><code>mkdir -p inputs/raw\nwget -O inputs/raw/HSM67VFJ.tar https://ibdmdb.org/tunnel/static/HMP2/WGS/1818/HSM67VFJ.tar\ntar xf inputs/raw/HSM67VFJ.tar -C inputs/raw\n</code></pre> <p>Adapter trim and (lightly) quality trim with fastp:</p> <pre><code>mkdir -p outputs/fastp\nfastp --in1 inputs/raw/HSM67VFJ_R1.fastq.gz \\\n      --in2 inputs/raw/HSM67VFJ_R2.fastq.gz \\\n      --out1 outputs/fastp/HSM67VFJ_R1.trim.fq.gz \\\n      --out2 outputs/fastp/HSM67VFJ_R2.trim.fq.gz \\\n      --detect_adapter_for_pe \\\n      --qualified_quality_phred 4 \\\n      --length_required 31 --correction \\\n      --json outputs/fastp/HSM67VFJ.json \\\n      --html outputs/fastp/HSM67VFJ.html\n</code></pre> <p>Remove \"host\" (e.g. human) DNA from the sequencing reads You will need the masked human k-mer data available here. Download and save this file to <code>inputs/host/inputs/host/hg19_main_mask_ribo_animal_allplant_allfungus.fa.gz</code>. This step can take up to 64GB of ram. To reduce this, change <code>-Xmx64g</code> to a lower number, e.g. <code>-Xmx16g</code>.</p> <pre><code>mkdir -p outputs/bbduk\nbbduk.sh -Xmx64g t=3 k=31 \\\n     in=outputs/fastp/HSM67VFJ_R1.trim.fq.gz \\\n     in2=outputs/fastp/HSM67VFJ_R2.trim.fq.gz \\\n     out=outputs/bbduk/HSM67VFJ_R1.nohost.fq.gz \\\n     out2=outputs/bbduk/HSM67VFJ_R2.nohost.fq.gz \\\n     outm=outputs/bbduk/HSM67VFJ_R1.human.fq.gz \\\n     outm2=outputs/bbduk/HSM67VFJ_R2.human.fq.gz \\\n     ref=inputs/host/hg19_main_mask_ribo_animal_allplant_allfungus.fa.gz\n</code></pre> <p>K-mer trim the reads. This step can take up to 60GB of ram as written. To reduce this, change <code>-M 60e9</code> to a lower number, e.g. <code>-M 16e9</code>. </p> <pre><code>mkdir -p outputs/abundtrim\ninterleave-reads.py outputs/bbduk/HSM67VFJ_R1.nohost.fq.gz outputs/bbduk/HSM67VFJ_R2.nohost.fq.gz | \\\n      trim-low-abund.py --gzip -C 3 -Z 18 -M 60e9 -V - -o outputs/abundtrim/HSM67VFJ.abundtrim.fq.gz\n</code></pre> <p>After quality control is complete, we'll use Groot to identify reads that encode antibiotic resistance genes.  Groot uses a database from which it identifies genes of interest.  Download the ARG90 database:</p> <pre><code>groot get -d arg-annot\n</code></pre> <p>Then, index the database. <code>-p</code> specifies how many threads to use during indexing.</p> <pre><code>groot index -m arg-annot.90 -i groot-index -w 100 -p 8\n</code></pre> <p>Run groot on the sequencing reads:</p> <pre><code>mkdir outputs/groot\ngroot align -i groot-index -f outputs/abundtrim/HSM67VFJ.abundtrim.fq.gz \\\n  -p 2 -g outputs/groot/HSM67VFJ_arg90.graph &gt; outputs/groot/HSM67VFJ_arg90.bam\n</code></pre> <p>And generate a report that summarizes the antibiotic resistance reads identified. <code>-c</code> indicates the amount of coverage for a gene to be reported.</p> <pre><code>groot report --bamFile outputs/groot/HSM67VFJ_arg90.bam -c .9 &gt; outputs/groot/HSM67VFJ_arg90_report.txt\n</code></pre> <p>The <code>groot report</code> function produces the following report:</p> <pre><code>argannot~~~(Bla)cfxA5~~~AY769934:28-993 1452    966     776M1D186M3D\nargannot~~~(Bla)cfxA~~~U38243:150-1115  1551    966     886M80D\nargannot~~~(Bla)CEP-A-44~~~U05885:556-1458      624     903     613M2D287M1D\nargannot~~~(Bla)cfxA4~~~AY769933:1-966  1453    966     963M3D\nargannot~~~(Tet)TetW~~~AJ222769:3687-5606       154     1920    44D1851M25D\nargannot~~~(Bla)cfxA2~~~AF504910:1-966  1606    966     501M6D456M3D\n</code></pre> <p>The columns specify <code>\"arg\", \"read_count\", \"gene_length\", \"coverage\"</code> of each antibiotic resistance gene in the sequencing sample.</p> <p>Using the bam file which recorded which reads map to which antibiotic resistance genes, we can estimate the proportion of reads that mapped to any ARG.</p> <pre><code>mapped=$(samtools view -c -F 4 outputs/groot/HSM67VFJ_arg90.bam)\nproportion=$(echo \"scale=10 ; $mapped / 10000000\" | bc)\nprintf \"HSM67VFJ,$proportion\" &gt; outputs/groot/HSM67VFJ_proportion.txt\n</code></pre> <p>We see that for this sample, a small proportion of reads mapped against the ARG database</p> <pre><code>HSM67VFJ,.0010801000\n</code></pre> <p>Now that we've identified which antibiotic resistance genes are in this sample, we can select one of them and use it as a spacegraphcats query to determine its context. We'll start by downloading the FASTA sequences for antibiotic resistance genes in the ARG database and indexing those sequences with samtools.</p> <pre><code>mkdir -p inputs/arg_db\nwget -O inputs/arg_db/argannot-args.fna https://github.com/will-rowe/groot/raw/master/db/full-ARG-databases/arg-annot-db/argannot-args.fna\nsamtools faidx inputs/arg_db/argannot-args.fna\n</code></pre> <p>Then, extract a single sequence that was identified in the sample.</p> <pre><code>mkdir -p outputs/arg90_matches\nsamtools faidx inputs/arg_db/argannot-args.fna argannot~~~(Bla)cfxA4~~~AY769933:1-966 &gt; outputs/arg90_matches/cfxA4_AY769933.fna\n</code></pre> <p>Make a configuration file for spacegraphcats, and save it as <code>outputs/sgc_conf/HSM67VFJ_r1_conf.yml</code>.</p> <pre><code>catlas_base: HSM67VFJ\ninput_sequences:\n- outputs/abundtrim/HSM67VFJ.abundtrim.fq.gz\nksize: 31\nradius: 1\nsearch:\n- outputs/arg90_matches/cfxA4_AY769933.fna\n</code></pre> <p>Run spacegraphcats to extract the sequence context around the antibiotic resistance gene.</p> <pre><code>python -m spacegraphcats run \\\n     outputs/sgc_conf/HSM67VFJ_r1_conf.yml \\\n     extract_contigs extract_reads \\\n     --nolock --outdir=outputs/sgc_arg_queries_r1 \\\n     --rerun-incomplete \n</code></pre> <p>Lastly, use bcalm and bandage to plot the context extracted by spacegraphcats.</p> <pre><code>mkdir -p outputs/bcalm/HSM67VFJ_r1\nbcalm -in outputs/sgc_arg_queries_r1/HSM67VFJ_k31_r1_search_oh0/cfxA4_AY769933.fna.cdbg_ids.reads.gz \\\n     -out-dir outputs/bcalm/HSM67VFJ_r1 \\\n     -kmer-size 31 -abundance-min 1 \\\n     -out outputs/bcalm/HSM67VFJ_r1/cfxA4_AY769933.fna.cdbg_ids.reads.gz\n</code></pre> <p>Download the script to convert the bcalm file to a gfa file</p> <pre><code>wget https://raw.githubusercontent.com/spacegraphcats/2018-paper-spacegraphcats/master/pipeline-analyses/variant_snakemake/convertToGFA.py\nchmod 777 convertToGFA.py\npython ./convertToGFA.py outputs/bcalm/HSM67VFJ_r1/cfxA4_AY769933.fna.cdbg_ids.reads.gz.unitigs.fa outputs/bcalm/HSM67VFJ_r1/cfxA4_AY769933.fna.cdbg_ids.reads.gz.unitigs.gfa 31\n</code></pre> <p>Use the bandage command line cli to plot the results with the antibiotic resistance gene highlighted.</p> <pre><code>mkdir -p outputs/bandage\nBandage image outputs/bcalm/HSM67VFJ_r1/cfxA4_AY769933.fna.cdbg_ids.reads.gz.unitigs.gfa \\\n     outputs/bandage/HSM67VFJ_r1/cfxA4_AY769933.fna.cdbg_ids.reads.gz.unitigs.png \\\n     --query outputs/arg90_matches/cfxA4_AY769933.fna\n</code></pre> <p>A snakemake pipeline encoding this workflow is available here. Running this workflow on all samples in the times series, we see that the context of the antibiotic resistance gene cfxA4 changes over time. Additionallly, using different radius sizes, we can see that the amount of sequencing context we get back increases with increasing radius size.</p> <p> Sequence context of antibiotic resistance gene cfxA4 over time and at different radiuses.</p>"},{"location":"02-spacegraphcats-use-cases/#working-with-spacegraphcats-results","title":"Working with spacegraphcats results","text":"<p>spacegraphcats is a powerful framework to organize and access unassembled reads in metagenomes, but the output is admittedly unsatisfying.  While spacegraphcats will give you the reads or k-mers in the neighborhood of your query, often times the reads you're most interested in are the ones that are the most difficult to work with -- the ones that:</p> <ol> <li>do not assemble</li> <li>do not match any sequences in databases</li> </ol> <p>We have some experiences with working with these kinds of reads and outline some approaches we have taken to working with them in the past.  This is still an active area of research that can benefit from the creativity of the metagenomics community!</p>"},{"location":"02-spacegraphcats-use-cases/#try-an-amino-acid-assembler","title":"Try an amino acid assembler","text":"<p>Sometimes reads do not assemble due to excessive strain variation. Amino acid assemblers reduce strain variation by translating reads into amino acid sequences prior to assembly. In particular, this reduces strain variation due to third base pair wobble, where in the third nucleotide in a codon can vary without changing the amino acid which it encodes.</p> <p>In the past, we have used the PLASS amino acid assembler somewhat successfully on spacegraphcats query neighborhoods. However, PLASS seems to produce many potential amino acid sequences at least in part influenced by combinatorial overlaps in potential protein sequences. This output can be difficult to wade through.</p> <p>Amino acid assemblers only produce amino acid sequences.  To map sequencing reads back to the assembly to estimate coverage depth or number of reads assembled, we have used paladin to map nucleotide reads to the amino acid assembly.</p>"},{"location":"02-spacegraphcats-use-cases/#use-read-level-analysis-tools","title":"Use read-level analysis tools","text":"<p>Tools like mifaser and GROOT perform annotation on reads instead of on assemblies.  These tools may provide insight into the content of a spacegraphcats query neighborhood.</p>"},{"location":"03-visualizing-spacegraphcats/","title":"spacegraphcats: visualizing spacegraphcats outputs","text":""},{"location":"03-visualizing-spacegraphcats/#producing-a-graph-of-the-catlas","title":"Producing a graph of the catlas","text":""},{"location":"03-visualizing-spacegraphcats/#using-bandage-to-view-assembly-graphs-of-spacegraphcats-neighborhoods","title":"Using bandage to view assembly graphs of spacegraphcats neighborhoods","text":"<p>Bandage is a useful tool for visualizing de bruijn graphs. </p> <p>An example of Bandage visualization that appeared on Galaxy toolshed is presented below along with its original caption.  (Note that for the graph on the left in part A, a perfect circle would only occur for closed genomes with no repeated k-mers.)</p> <p></p> <p>Bandage allows the user to visualize a complete or partial compact de Bruijn graph.  We have used Bandage to visualize a query neighborhood from spacegraphcats.</p> <p>For example, we used Bandage to visualize the neighborhood of gyrA, a universal single copy marker gene in bacteria.  We performed spacegraphcats neighborhood queries, identified reads of interest within those queries, plotted assembly graphs of those reads, and observed the structure.  Four are seen below.  These graphs are nice because they demonstrate the diversity of potential sequences present in a neighborhood. </p> <p></p> <p>Because real (meta)genomes are usually complex, we have found it most useful to use Bandage for small spacegraphcat queries, or for a subset of a neighborhood. </p> <p>To use bandage, first build a compact de bruijn graph using BCALM from the reads you're interested in visualizing.</p> <p>An example command is below. This command uses reads from a query neighborhood produced by querying a metagenome with a genome bin. </p> <pre><code>bcalm -in SRR1211157_bin.8.fa.gz.cdbg_ids.reads.fa.gz -kmer-size 31\n</code></pre> <p>You may want to add <code>-abundance-min 1</code> if you're using contigs or assemblies in this, otherwise bcalm will fragment the graph at k-mers that only appear once.</p> <p>Next, convert the graph to <code>gfa</code> format using the utility script <code>convertToGFA.py</code></p> <pre><code>wget https://raw.githubusercontent.com/spacegraphcats/2018-paper-spacegraphcats/master/pipeline-analyses/variant_snakemake/convertToGFA.py\npython ./convertToGFA.py SRR1211157_bin.8.fa.gz.cdbg_ids.reads.fa.unitigs.fa SRR1211157_bin.8.fa.gz.cdbg_ids.reads.fa.gfa 31\n</code></pre> <p>To use Bandage, you'll need to install it from its website.  Although it has a CLI, the GUI is useful for exploring a graph.  See https://rrwick.github.io/Bandage/ for download.</p> <p>To plot a graph using Bandage, open the graph using Bandage <code>File</code> &gt; <code>Load graph</code></p> <p>Then select <code>draw graph</code> to visualize.  If you load a very large graph (e.g. an entire metagenome, or a large query neighborhood), it can take hours to plot.</p> <p>To BLAST against the graph, you need to have BLAST installed and in your path.  One way to do this is to create a conda environment and install blast</p> <pre><code>conda create -n blast  blast=2.9.0 \nconda activate blast\n</code></pre> <p>Then symlink the blast executable into <code>/usr/local/bin</code>, where Bandage looks for it</p> <pre><code>ln -s  ~/miniconda3/envs/blast/bin/blastn /usr/local/bin/\nln -s  ~/miniconda3/envs/blast/bin/tblastn /usr/local/bin/\n</code></pre> <p>Then, click <code>Create/view BLAST search</code> and follow the instructions.  BLAST allows you to visualize e.g. a specific protein or sequence on your graph.</p>"},{"location":"04-spacegraphcats-parameters/","title":"Spacegraphcats parameters","text":"<p>There are two parameters that control the behavior of spacegraphcats: k-mer size (k) and radius size (r). Both of these parameters are specified in the config file. We have tested spacegraphcats behavior most extensively with a k-size = 31 and radius = 1, but below we explore how these parameters behave with different values in real metagenomes.  As we have not exhaustively tested different parameters, below we discuss the role of these parameters in changing spacegraphcats outputs in the context of a variety of sequencing data.  Our goal is to help the user build an intuition for the behavior of these parameters and how they may impact spacegraphcats output in the context of different sequencing data. </p>"},{"location":"04-spacegraphcats-parameters/#k-mer-size","title":"K-mer size","text":"<p>The k-mer size is used to build the compact de Bruijn graph (cDBG, e.g. assembly graph). Smaller k-mer sizes will collapse more sequences together.  This can be seen in a supplemental graph from the Bandage publication, included below.  On the far left, the graph is built with a k-mer size of 21 and appears as a denser component than the graph on the far right that is built with a k-merm size of 127.</p> <p> Source Wick et al. 2015</p> <p>Most metagenome assemblers iteratively build assembly graphs with different k-mer sizes, and select the paths in the graphs that generate the longest/least branching paths to generate linear contigs.  Spacegraphcats uses a single k-mer size to generate its cDBG.  As is seen in the picture above, this will impact the topology of the cDBG.</p> <p>We use a k = 31 as the \"default\" k-mer size in spacegraphcats.  We selected this size because there is substantial k-mer overlap between genomes from the same species at a k-size of 31 (see the Metapalette paper for a larger discussion of sequence similarity between genomes at different k sizes.) Because of this overlap, it follows that k-mers from the same species would be graph-adjacent in the cDBG.</p> <p>Note that there is substantial overlap between genomes of the same genus at a k-size of 21, and substantial overlap between genomes of the same strain at a k-size of 51.</p>"},{"location":"04-spacegraphcats-parameters/#radius-size","title":"Radius size","text":"<p>The radius size controls the maximum distance a node in the cDBG can be from a dominating node.  The figure below is reproduced from the spacegraphcats paper.  \"Starting from a collection of genomic sequences (a), we form an assembly graph where nodes represent distinct linear subsequences (b).  In this assembly graph, known as a compact De Bruijn graph, nodes may represent many k-mers.  The original genomic sequences correspond to walks in the graph, and shared nodes between the walks represent shared subsequences.  c We then identify a subset of nodes D called a dominating set so that every node in the assembly graph is at distance at most one from some member of D (marked pink).  We further partition the graph into pieces by assigning every node to exactly one of the closest members of D (beige regions in c and d).  For a genomic query Q, the neighborhood of Q in this graph is the union of all pieces which share at least one k-mer with the query.  The colorful subsets of the pieces in d correspond to the neighborhoods of the queries Q1,Q2</p> <p> Source: Brown et al. 2020 </p> <p>In this figure, the dominating set has a radius = 1, where any node is at most distance 1 from a node in the dominating set.  As the radius expands, the pieces \"dominated\" by each node in the dominating set will contain more nodes, and therefore more nucleotides.</p>"},{"location":"04-spacegraphcats-parameters/#the-defaults-k-31-r-1","title":"The defaults: k = 31, r = 1","text":"<p>When using the \"default\" spacegraphcats parameters, relatively little k-mer sequence overlap is necessary between the query sequence and the query neighborhood to recover substantial portions of closely related genomes. The figure below is reproduced from the spacegraphcats paper.  It demonstrates that with a Jaccard similarity between 10<sup>-2</sup> and 10<sup>-3</sup>, 20-40% of a target genome sequence is recovered from a metagenome query.  This jumps to &gt;80% when Jaccard similarity exceeds 10<sup>-1</sup>.  Panel B shows that an approximately 1 Mbp overlap between two genomes is sufficient to recover approximately 2.3 Mbp of unknown sequence from the closely related Proteiniclasticum genomes.</p> <p> Source: Brown et al. 2020</p> <p>Below, we show an approximate conversion between Jaccard similarity and Average Nucleotide Identity (ANI) at different k-mer sizes using simulated sequences (notebook here). A Jaccard similarity of 0.10 corresponds approximately to 95% ANI at a k-mer size of 31.</p> <p> Image courtesy of Tessa Pierce Ward.</p>"},{"location":"04-spacegraphcats-parameters/#do-unwanted-sequences-sneak-in-especially-at-larger-radius-sizes","title":"Do unwanted sequences sneak in, especially at larger radius sizes?","text":"<p>Generally speaking, we have not found that spacegraphcats genome queries on real metagenomes on catlases built with a k-size of 31 and a radius of 1 accidentally scoop in extra k-mers from the wrong taxonomy, but we have not tested this systematically. </p> <p>Anecdotally:</p> <ol> <li>When we queried into ~600 human stool metagenomes using a genome sequence from Rumminococcus gnavus and with parameters k = 31 and r = 1, running strainphlan on the resulting query neighborhoods indicated that only R. gnavus was present.</li> <li>Using the same query neighborhoods described above, running singleM demonstrated that some query neighborhoods contained reads from marker genes consistent with different taxonomic ranks.  Singlem searches reads for 14 marker genes, and assigns taxonomy to a sample based on those marker genes.  Given that there is more likely to be shared k-mers in conserved single copy marker genes, it is possible that spacegraphcats pulls in some reads from these conserved regions.</li> <li>Using a gene of interest as a query, query neighborhoods often contain variation for that gene, as well sequences for upstream genes that are typcially co-located in a genome (e.g. querying with gyrA leads to the paritial recover of gyrB). </li> </ol>"},{"location":"04-spacegraphcats-parameters/#querying-a-metagenome-with-a-complete-metagenome-assembled-genome","title":"Querying a metagenome with a \"complete\" metagenome assembled genome","text":"<p>Metagenome assembled genomes are composite genomes comprising fragmented genome sequences from closely related genomes in a community. Generally, these genomes are highly fragmented due to assembly errors that arise from, among other things, strain variation and shallow sequencing coverage. \"Complete\" metagenome assembled genomes (CMAGs) are circularized metagenome assembled genomes with no gaps (see Chen et al. 2020). In multi-species communities, there are likely specific ecoevolutionary conditions that lead to sequencing data that allow the potential recovery of a CMAGs. For this to be possible, a genome likely needs to have very little strain variation, high abundance/coverage, and not be closely related to other genomes in the population.     </p> <p>Given these conditions, we were curious whether  1. CMAGs contain additional variation not captured by curation techniques, and  2. Using spacegraphcats to query a metagenome with a CMAG it precipitated leads to the recovery of \"off target\" sequences. </p> <p>A Snakemake workflow is available for this analysis here.</p> <p>After k-mer trimming the metagenome, we used a CMAG to query into the assembly graph.  We retrieved the reads for the query neighborhood and mapped these back to the CMAG assembly, and then retrieved unmapped reads. 99.82% of reads in the query neighborhood mapped back to the query, indicating there was little strain variation in the reads not accounted for in the assembly. Using megahit, the unmapped reads assembled into 5 contigs ranging in size from 179-208bp.  When BLASTed (<code>blastn</code>, <code>blastx</code>) against the NCBI nr database, four of the five contigs matched 16S or 23S ribosomal RNA.  This likely indicates that sequences that are highly conserved between distantly related species may be included in spacegraphcats query neighborhoods; users should keep this in mind when asking biological questions about highly conserved sequences (e.g. ribosomal RNA).  The fifth sequence had no nucleotide matches, but matched a hypothetical protein Candidatus Uhrbacteria bacterium RIFOXYA2_FULL_40_9. This may indicate strain variation in these hypothetical protein sequence not captured in the CMAG.</p> <pre><code> hypothetical protein A2239_02390 [Candidatus Uhrbacteria bacterium RIFOXYA2_FULL_40_9]\nSequence ID: OGL93914.1\nLength: 354\nNumber of Matches: 1\n\nIdentical Proteins-Identical proteins to OGL93914.1\nRange 1: 314 to 354\nAlignment statistics for match #1 Score Expect  Method  Identities  Positives   Gaps    Frame\n85.1 bits(209)  2e-17   Compositional matrix adjust.    41/41(100%)     41/41(100%)     0/41(0%)    -1\n\nQuery  201  SEEEQEAHWKLYEDSLAYLVAHPDEYRALNAVGLLEEFDWE  79\n            SEEEQEAHWKLYEDSLAYLVAHPDEYRALNAVGLLEEFDWE\nSbjct  314  SEEEQEAHWKLYEDSLAYLVAHPDEYRALNAVGLLEEFDWE  354\n</code></pre>"},{"location":"04-spacegraphcats-parameters/#exploring-taxonomy-of-cdbg-nodes-within-dominators-using-a-simple-metagenome","title":"Exploring taxonomy of cDBG nodes within dominators using a simple metagenome","text":"<p>Below we explore the taxonomy of spacegraphcats results using the experimental synthetic metagenome. The metagenome was published by Shakya et al., 2013. It contains sequences from isolate DNA that were aliquoted together prior to sequencing, so it is less complex than real community metagenomes. Two of the genomes are different strains from the same species, and one of the genomes is a completely different class from the other two.  In spacegraphcats land, we refer to a subset of this data as <code>twofoo</code>.</p> <p>The utility script <code>explore-dominator-taxonomy.py</code> - Takes all sourmash hashes in the dataset and retrieves the cDBG unitig IDs to which they belong; - It then aggregates those hashes under the dom nodes to which those cDBG unitigs belong; - Finally, it calculates the taxonomy of the dom node based on the LCA of the hash values.</p> <p>Below we show the taxonomy results when <code>r = 1</code> and <code>r = 5</code>.</p> <pre><code>scripts/explore-dominator-taxonomy.py twofoo_k31_r1 twofoo_k31_r1_hashval_k31/index.pickle ../sourmash/podar-ref.lca.json.gz\n</code></pre> <p>Gives the following results:</p> <pre><code>88512 dom nodes have no sourmash hashes under them.\n903 dom nodes have exactly one sourmash hash under them.\n37 dom nodes have two or more sourmash hashes under them.\n\nrank of dom node lca  count of dom nodes with that rank\n--------------------  ---------------------------------\nstrain                  35\nspecies                  2\n</code></pre> <p>What we see is that the graphs for the two different species are completely non-overlapping (at least at the resolution of sourmash k=31 scaled=1000) while the graphs for the genomes from the same strain are overlapping.</p> <p>More specifically, 35 of the dom nodes have cDBG nodes with two or more hashvals under them that belong to the same strain, while only two of the dom nodes contain cDBGs with hashvals from the two different strains.  At the resolution we're using here, the vast majority of cDBG nodes and dom nodes have no associated hashvals, which maybe says we should be using higher resolution sourmash or larger r!</p> <p>Using a radius of 5:</p> <pre><code>loaded 27124 nodes from catlas twofoo_k31_r5\nloaded 15031 layer 1 catlas nodes\nloaded 9447551 k-mers in index (0.4s)\nloaded 985 hash value -&gt; cdbg_id mappings from twofoo_k31_r5_hashval_k31/index.pickle\n14149 dom nodes have no sourmash hashes under them.\n796 dom nodes have exactly one sourmash hash under them.\n86 dom nodes have two or more sourmash hashes under them.\n\nrank of dom node lca  count of dom nodes with that rank\n--------------------  ---------------------------------\nstrain                  76\nspecies                  10\n</code></pre> <p>The higher radius 'annotates' more dom nodes with taxonomy. In this example, there is still no increase in taxonomic confusion above the species level, which is good and expected for synthetic data.</p>"},{"location":"05-alpha-spacegraphcats/","title":"Alpha functionality","text":"<p>While we have some tried and true use cases for spacegraphcats, we have even more \"alpha functionality\" -- functionality for which the code and rationale exist, and may have even been run quite a few times, but that hasn't been extensively explored or applied to many real biological problems yet.  We document this functionality below.  </p>"},{"location":"05-alpha-spacegraphcats/#querying-by-sourmash-minhash-hash-values","title":"Querying by sourmash minhash hash values","text":"<p>Sourmash enables rapid comparisons across large sequencing datasets using scaled minhashing.  Essentially, sourmash takes a sequence, decomposes it into k-mers, transforms those k-mers into a number via a hash function, and subsamples the numbers.  This generates a minhash signatures, or a compressed representation, of the original sequencing data, thereby allowing for rapid comparisons even against millions of genomes. We enabled querying by hash value to allow integration of sourmash and spacegraphcats workflows. </p> <pre><code>spacegraphcats &lt;conf&gt; hashval_query\n</code></pre> <pre><code>spacegraphcats &lt;conf&gt; extract_reads_for_hashvals\n</code></pre> <p>The <code>hashval_ksize</code> parameter can be different from the k-mer size used to build the cDBG. However, for now you can only specify one in a config file; make duplicate config files with different <code>hashval_ksize</code> values to do queries on multiple ksizes.</p> <p>In practice, we have not found querying only by hash value extremely useful; sourmash (typically) subsamples to 1/1000th or 1/2000th of the k-mers in a sequence. Subsampling facilitates rapid and accurate comparisons between sequences, but this resolution provides an incomplete picture of the sequence landscape, missing a lot of important sequence context (e.g. genes, etc.). Potentially more importantly, while querying with a hash value may return reads in the neighborhood of the k-mer represented by that hash value, those reads may or may not assemble. If they do not assemble, it becomes really hard to identify what the functional/taxonomic identity of that hash value may be. We realized this after implementing <code>hashval_query</code> and <code>extract_reads_for_hashvals</code>, and then implemented multifasta queries (see next section).</p>"},{"location":"05-alpha-spacegraphcats/#multifasta-queries","title":"Multifasta queries","text":"<p>To circumvent assembly issues that may occur if reads in a neighborhood of a hash value do not assemble, we developed a \"multifasta query\" that transfers the annotation of a gene query to hash values in that gene's neighborhood. The underlying goal of \"multifasta queries\" is to annotate hash values with genes that are in their graph neighborhood.</p> <p>To do this, spacegraphcats builds an index with a set of FASTA records, e.g. gene sequences from a reference genome, and then queries with a set of \"interesting\" hash values. Spacegraphcats will output a CSV file containing hashval-to-record-name multimappings, where both hash values and record names may appear multiple times.</p> <p>To run a multifasta query, the configuration file should include multifasta-specific fields:</p> <pre><code>multifasta_reference:\n- GCF_000021665.1_ASM2166v1_cds_from_genomic.fna\n\nmultifasta_scaled: 1000\nmultifasta_query_sig: data/63-os223.sig\n</code></pre> <p>Where the <code>multifasta_reference</code> contains the gene in a query of interest, <code>multifasta_scaled</code> indicates the scaled value for sourmash to use, and <code>multifasta_query_sig</code> is a sourmash signature file that contains the hash values that represent k-mers of interest.</p> <p>Then, run spacegraphcats:</p> <pre><code>python -m spacegraphcats run twofoo multifasta_query\n</code></pre>"},{"location":"05-alpha-spacegraphcats/#graphgrep","title":"graphgrep","text":"<p><code>graphgrep</code> takes a different approach to querying the CDB than is implemented with the catlas.  The goal of <code>graphgrep</code> is to simplify the retrieval of contigs and/or reads based on k-mer queries into the cDBG. To do this, it implements a <code>--radius</code> option that does neighborhood retrieval in a way that is different from catlas neighborhood expansion. Briefly, <code>--radius</code> does a local expansion around matching cDBG nodes without using dominators, which means 1) the catlas does not need to be built, which helps address our current memory issues where in some cases, catlas building is the blocking step; 2) the reads/contigs output here are different from (a superset of) the reads output by our current neighborhood query. The k-mer index is still required for <code>graphgrep</code>.</p> <p>A sister command, <code>graphgrep_iter</code> does the search without having a k-mer index into the cDBG.</p> <p>For large and/or many queries, we expect this code to be (much) slower than spacegraphcats neighborhood retrieval.  <code>graphgrep_iter</code> will also be quite slow for large graphs.</p> <p>The read index is still required to output reads instead of contig.</p> <p>The k-mer index and the reads index are the slowest of the indexing operations performed in a full catlas build, so <code>graphgrep*</code> doesn't solve these performance issues. However, in the specific case where k-mer indexing or catlas building can't be done due to RAM limitations, this may be a useful solution.</p> <p><code>graphgrep*</code> is currently implemented in pull request #372 and is not a part of the main code base. </p> <p>Basic usage:</p> <p>Output contigs to stdout:</p> <pre><code>python -m spacegraphcats.search.graphgrep twofoo-short twofoo-short_k31 twofoo-short_k31_r1 tests/test-data/63.short.fa.gz\n</code></pre> <p>Output reads to stdout:</p> <pre><code>python -m spacegraphcats.search.graphgrep -R twofoo-short twofoo-short_k31 twofoo-short_k31_r1 tests/test-data/63.short.fa.gz\n</code></pre>"},{"location":"05-alpha-spacegraphcats/#querying-a-nucleotide-catlas-with-protein-sequences","title":"Querying a nucleotide catlas with protein sequences","text":"<p>Some biological questions may be better answered with protein queries instead of with nucleotide queries. Protein queries work by building secondary indices on top of the cDBG unitigs, allowing spacegraphcats to anchor protein k-mers to their source DNA unitigs and reads. To acheive this, the catlas is built from the cDBG as normal. Then, a second index is built from the unitigs where the unitigs are translated into protein space and the protein k-mers are connected to the unitigs. These two indices support protein queries.</p> <p>Below we illustrate some results obtained from running a protein query.</p> <p>Using the podar metagenome, the following code performs a protein query with Proteiniclasticum ruminis proteome for the assembly <code>GCF_000701905.1</code>. Then, DNA contigs are extracted the DNA contigs for the results to see what other nucleotides they match against (genome-wise and taxonomically).</p> <p>The goal of this small use case was to see how much of what is known to be in the metagenome based on DNA matches (to the <code>GCF_000701905.1</code> genome as well as the rest of genbank) is recovered by proteome search, as well as to evaluate the \"false positives\" caused by the much more sensitive proteome search.</p> <pre><code># do protein search\npython scripts/query-unitigs-prot.py podarV-prot/GCF_000701905.1_ruminis.faa.gz podarV_k31/bcalm.unitigs.db --output-prefix podarV_prot_ruminis\n\n# extract direct-match contigs to FASTA file \npython -m spacegraphcats.search.extract_contigs --contigs-db podarV_k31/bcalm.unitigs.db podarV_prot_ruminis.nodes.gz -o podarV_prot_ruminis/podarV_prot_ruminis.nodes.contigs.fa\n\n# take matching unitig IDs, inflate to neighborhood\npython -m spacegraphcats.search.extract_neighborhoods_by_cdbg_ids podarV_k31_r1 podarV_prot_ruminis.nodes.gz -o podarV_prot_ruminis/podarV_prot_ruminis.nbhd.nodes.gz\n\n# extract sequences for nbhd to FASTA file\npython -m spacegraphcats.search.extract_contigs --contigs-db podarV_k31/bcalm.unitigs.db -o podarV_prot_ruminis/podarV_prot_ruminis.nbhd.contigs.fa podarV_prot_ruminis/podarV_prot_ruminis.nbhd.nodes.gz\n\n# calculate signature with sourmash\ncd podarV_prot_ruminis\nsourmash compute -k 31 --scaled 1000 *.fa\n\n# search the sequences\nsourmash gather *.nodes.*.sig ~/genome-grist/outputs.paper/genbank/SRR606249.x.genbank.matches.sig\nsourmash gather *.nbhd.*.sig ~/genome-grist/outputs.paper/genbank/SRR606249.x.genbank.matches.sig\n</code></pre> <p>From this code, we learn the following insights about the behavior of protein queries.</p> <p>First, let's look at the gather results with and without neighborhood expansion. </p> <p>gather results without neighborhood expansion</p> <pre><code>== This is sourmash version 3.5.0. ==\n== Please cite Brown and Irber (2016), doi:10.21105/joss.00027. ==\n\nselect query k=31 automatically.\nloaded query: podarV_prot_ruminis.nodes.cont... (k=31, DNA)\nloading from /home/ctbrown/genome-grist/outputs.paper/genbank/SRR606249.x.genbanloaded 73 signatures from /home/ctbrown/genome-grist/outputs.paper/genbank/SRR60loaded 73 signatures.\n\n\noverlap     p_query p_match\n---------   ------- -------\n1.9 Mbp       29.0%   77.3%    GCA_003514505.1 Proteiniclasticum sp....\n222.0 kbp      3.3%    6.1%    GCA_000015865.1 Hungateiclostridium t...\n170.0 kbp      2.5%    6.3%    GCA_000172575.2 Enterococcus faecalis...\n158.0 kbp      2.4%    5.8%    GCA_000016545.1 Caldicellulosiruptor ...\n146.0 kbp      2.2%    6.6%    GCA_000019085.1 Thermoanaerobacter ps...\n118.0 kbp      1.8%    4.1%    GCA_000008185.1 Treponema denticola A...\n118.0 kbp      1.7%    4.2%    GCA_000022325.1 Caldicellulosiruptor ...\n116.0 kbp      1.7%    1.2%    GCA_000013645.1 Paraburkholderia xeno...\n107.0 kbp      1.6%    5.8%    GCA_000021645.1 Dictyoglomus turgidum...\n0.6 Mbp        1.6%    3.2%    GCA_900115135.1 Proteiniclasticum rum...\n93.0 kbp       1.4%    3.8%    GCA_013137915.1 Fusobacterium nucleat...\n87.0 kbp       1.3%    1.7%    GCA_000022185.1 Chloroflexus aurantia...\n86.0 kbp       1.3%    1.4%    GCA_002959695.1 Bacteroides thetaiota...\n85.0 kbp       1.3%    2.2%    GCA_000007985.2 Geobacter sulfurreduc...\n81.0 kbp       1.2%    1.1%    GCA_000009705.1 Nostoc sp. PCC 7120 =...\n79.0 kbp       1.2%    3.6%    GCA_000006985.1 Chlorobaculum tepidum...\n79.0 kbp       1.2%    2.9%    GCA_000020465.1 Chlorobium limicola D...\n75.0 kbp       1.1%    2.6%    GCA_000156375.1 Desulfovibrio piger A...\n75.0 kbp       1.1%    3.7%    GCA_900637325.1 Wolinella succinogene...\n73.0 kbp       1.1%    3.7%    GCA_000021565.1 Persephonella marina ...\n68.0 kbp       1.0%    3.7%    GCA_000018945.1 Thermotoga neapolitan...\n66.0 kbp       1.0%    2.2%    GCA_000020645.1 Pelodictyon phaeoclat...\n66.0 kbp       1.0%    1.2%    GCA_000195675.1 Bordetella bronchisep...\n63.0 kbp       0.9%    2.3%    GCA_000020225.1 Akkermansia muciniphi...\n63.0 kbp       0.9%    1.9%    GCA_003513425.1 Desulfovibrio sp., AS...\n60.0 kbp       0.9%    2.1%    GCA_000015125.1 Chlorobium phaeobacte...\n57.0 kbp       0.8%    1.2%    GCA_000011965.2 Ruegeria pomeroyi DSS...\n57.0 kbp       0.8%    0.9%    GCA_000018565.1 Herpetosiphon auranti...\n57.0 kbp       0.8%    1.4%    GCA_000022565.1 Acidobacterium capsul...\n56.0 kbp       0.8%    1.2%    GCA_000019785.1 Leptothrix cholodnii ...\n53.0 kbp       0.8%    1.9%    GCA_000009145.1 Nitrosomonas europaea...\n53.0 kbp       0.8%    1.1%    GCA_000012825.1 Bacteroides vulgatus ...\n53.0 kbp       0.8%    1.6%    GCA_001638825.1 Deinococcus radiodura...\n52.0 kbp       0.8%    1.0%    GCA_000017325.1 Shewanella baltica OS...\n51.0 kbp       0.8%    2.4%    GCA_003054575.1 Zymomonas mobilis sub...\n51.0 kbp       0.8%    2.4%    GCA_003450455.1 Thermus sp., ASM345045v1\n51.0 kbp       0.7%    2.4%    GCA_000016085.1 Chlorobium phaeovibri...\nfound less than 50.0 kbp in common. =&gt; exiting\n\nfound 37 matches total;\nthe recovered matches hit 74.4% of the query\n</code></pre> <p>gather results against the neighborhood</p> <pre><code>== This is sourmash version 3.5.0. ==\n== Please cite Brown and Irber (2016), doi:10.21105/joss.00027. ==\n\nselect query k=31 automatically.\nloaded query: podarV_prot_ruminis.nbhd.conti... (k=31, DNA)\nloading from /home/ctbrown/genome-grist/outputs.paper/genbank/SRR606249.x.genbanloaded 73 signatures from /home/ctbrown/genome-grist/outputs.paper/genbank/SRR60loaded 73 signatures.\n\n\noverlap     p_query p_match\n---------   ------- -------\n2.0 Mbp       23.0%   81.2%    GCA_003514505.1 Proteiniclasticum sp....\n318.0 kbp      3.6%    8.7%    GCA_000015865.1 Hungateiclostridium t...\n227.0 kbp      2.6%    8.4%    GCA_000172575.2 Enterococcus faecalis...\n209.0 kbp      2.4%    7.6%    GCA_000016545.1 Caldicellulosiruptor ...\n197.0 kbp      2.2%    8.9%    GCA_000019085.1 Thermoanaerobacter ps...\n191.0 kbp      2.1%    2.0%    GCA_000013645.1 Paraburkholderia xeno...\n161.0 kbp      1.8%    5.8%    GCA_000022325.1 Caldicellulosiruptor ...\n155.0 kbp      1.7%    5.4%    GCA_000008185.1 Treponema denticola A...\n141.0 kbp      1.6%    5.7%    GCA_013137915.1 Fusobacterium nucleat...\n138.0 kbp      1.6%    7.5%    GCA_000021645.1 Dictyoglomus turgidum...\n132.0 kbp      1.5%    1.8%    GCA_000009705.1 Nostoc sp. PCC 7120 =...\n127.0 kbp      1.4%    3.4%    GCA_000007985.2 Geobacter sulfurreduc...\n127.0 kbp      1.4%    2.5%    GCA_000022185.1 Chloroflexus aurantia...\n121.0 kbp      1.4%    1.9%    GCA_002959695.1 Bacteroides thetaiota...\n0.6 Mbp        1.2%    3.3%    GCA_900115135.1 Proteiniclasticum rum...\n107.0 kbp      1.2%    3.7%    GCA_000156375.1 Desulfovibrio piger A...\n105.0 kbp      1.2%    4.8%    GCA_000006985.1 Chlorobaculum tepidum...\n105.0 kbp      1.2%    5.2%    GCA_900637325.1 Wolinella succinogene...\n101.0 kbp      1.1%    3.7%    GCA_000020465.1 Chlorobium limicola D...\n101.0 kbp      1.1%    5.1%    GCA_000021565.1 Persephonella marina ...\n99.0 kbp       1.1%    3.3%    GCA_000020645.1 Pelodictyon phaeoclat...\n96.0 kbp       1.1%    1.8%    GCA_000195675.1 Bordetella bronchisep...\n95.0 kbp       1.1%    3.3%    GCA_000015125.1 Chlorobium phaeobacte...\n92.0 kbp       1.0%    5.0%    GCA_000018945.1 Thermotoga neapolitan...\n92.0 kbp       1.0%    2.8%    GCA_001638825.1 Deinococcus radiodura...\n91.0 kbp       1.0%    2.8%    GCA_003513425.1 Desulfovibrio sp., AS...\n90.0 kbp       1.0%    1.4%    GCA_000018565.1 Herpetosiphon auranti...\n89.0 kbp       1.0%    1.8%    GCA_000012825.1 Bacteroides vulgatus ...\n89.0 kbp       1.0%    3.3%    GCA_000020225.1 Akkermansia muciniphi...\n87.0 kbp       1.0%    1.9%    GCA_000011965.2 Ruegeria pomeroyi DSS...\n86.0 kbp       0.9%    1.7%    GCA_000019785.1 Leptothrix cholodnii ...\n83.0 kbp       0.9%    2.0%    GCA_000022565.1 Acidobacterium capsul...\n80.0 kbp       0.9%    1.5%    GCA_000017325.1 Shewanella baltica OS...\n79.0 kbp       0.9%    3.8%    GCA_000016085.1 Chlorobium phaeovibri...\n77.0 kbp       0.9%    2.8%    GCA_000009145.1 Nitrosomonas europaea...\n77.0 kbp       0.9%    3.6%    GCA_003054575.1 Zymomonas mobilis sub...\n70.0 kbp       0.8%    1.3%    GCA_000007345.1 Methanosarcina acetiv...\n68.0 kbp       0.8%    1.5%    GCA_000010305.1 Gemmatimonas aurantia...\n68.0 kbp       0.8%    3.2%    GCA_003450455.1 Thermus sp., ASM345045v1\n59.0 kbp       0.7%    3.7%    GCA_000020785.1 Hydrogenobaculum sp. ...\n56.0 kbp       0.6%    1.0%    GCA_000018265.1 Salinispora arenicola...\n54.0 kbp       0.6%    0.8%    GCA_000196115.1 Rhodopirellula baltic...\nfound less than 50.0 kbp in common. =&gt; exiting\n\nfound 42 matches total;\nthe recovered matches hit 75.3% of the query\n</code></pre> <p>Insights</p> <ul> <li>Protein queries lead to good genome recovery. <ul> <li>From the gather results, we see that 77/81% of a Proteiniclasticum genome (top match) was recovered.</li> <li>It's a different genome than the source of the proteome. This is a little unexpected but could make sense - we assume that the proteome search recovered sequences that overlap slightly more sequences from the best-matched assembly than with the query itself.</li> </ul> </li> <li>Subsequent matches have increasingly distant taxonomic relationship to P. ruminis. This is likely evidence that the protein query picks up real matches that are more distantly related than would be recovered with nucleotide queries.<ul> <li>The second match, Hungateiclostridium, is in the same order as P. ruminis - Clostridiales - but not the same family or genus.</li> <li>Third best match is to Enterococcus faecalis which is only in the same phylum, Firmicutes, as our query.</li> <li>Fourth best match is to Caldicellulosiruptor, same order.</li> <li>Fifth best match is Thermoanaerobacter, same order.</li> <li>This match structure holds true for both node search and neighborhood search, suggesting that the protein search is pretty powerful at finding good matches and the neighborhood inflation is icing on the cake, so to speak.</li> </ul> </li> <li>About 75% of the resulting contigs are matched. When compared against a nucleotide neighborhood search for P. ruminis that contains novel P. ruminis sequence, we see that the containment for these sequences is pretty good, suggesting that the proteome search picks out the majority of the genome found with the regular nucleotide spacegraphcats query. </li> </ul> <pre><code>% sourmash search --containment ruminis-genome.sgc-paper.fa.sig podarV*.sig\n...\nsimilarity   match\n----------   -----\n 85.0%       podarV_prot_ruminis.nbhd.contigs.fa\n 81.1%       podarV_prot_ruminis.nodes.contigs.fa\n</code></pre> <p>Expanding to the protein, the containment drops, suggesting that extra sequences occur in the protein neigborhoods.</p> <pre><code>% sourmash search ruminis-genome.sgc-paper.fa.sig podarV*.sig\n...\nsimilarity   match\n----------   -----\n 31.8%       podarV_prot_ruminis.nodes.contigs.fa\n 26.0%       podarV_prot_ruminis.nbhd.contigs.fa\n</code></pre> <p>There is a lot to be done with understanding how protein searches work, and what all they bring in.  Please keep this in mind if you choose to use this functionality!</p>"},{"location":"06-snakemake-spacegraphcats/","title":"Integrating spacegraphcats into a snakemake workflow","text":"<p>This page is under construction, please check back as we add more documentation! Snakemake is a workflow manager that automates and scales bioinformatics pipelines, and makes them portable across computing environments.</p>"},{"location":"06-snakemake-spacegraphcats/#a-sample-snakemake-workflow","title":"A sample snakemake workflow","text":"<p>See a sample snakemake workflow for a spacegraphcats pipeline here.</p> <p>The spacegraphcats rule is copied below:</p> <pre><code>rule spacegraphcats_one_arg:\n    input: \n        query = \"outputs/arg90_matches/cfxA4_AY769933.fna\", \n        conf = \"outputs/sgc_conf/{sample}_r{radius}_conf.yml\",\n        reads = \"outputs/abundtrim/{sample}.abundtrim.fq.gz\"\n    output:\n        \"outputs/sgc_arg_queries_r{radius}/{sample}_k31_r{radius}_search_oh0/cfxA4_AY769933.fna.cdbg_ids.reads.gz\",\n        \"outputs/sgc_arg_queries_r{radius}/{sample}_k31_r{radius}_search_oh0/cfxA4_AY769933.fna.contigs.sig\"\n    params: outdir = lambda wildcards: \"outputs/sgc_arg_queries_r\" + wildcards.radius\n    conda: \"envs/spacegraphcats.yml\"\n    resources:\n        mem_mb = 64000\n    threads: 1\n    shell:'''\n    python -m spacegraphcats run {input.conf} extract_contigs extract_reads --nolock --outdir={params.outdir} --rerun-incomplete \n    '''\n</code></pre>"},{"location":"06-snakemake-spacegraphcats/#configuration-files","title":"Configuration files","text":"<p>Spacegraphcats requires a configuration file that specifies run parameters like k-mer size and radius, and base file names.  This configuration file can be generated by hand prior to running a workflow, by script prior to running a workflow, or automatically by the workflow.</p>"},{"location":"06-snakemake-spacegraphcats/#generating-configuration-files-prior-to-running-snakemake","title":"Generating configuration files prior to running snakemake","text":"<p>If the spacegraphcats queries are defined prior to running a workflow, the configuration file can be generated prior to running the workflow.  Below we include some python code to generate multiple configuration files.  This code assumes that sample names are stored in a metadata csv file, and that abundance trimmed reads are stored in a directory called <code>outputs/abundtrim</code>. It writes configuration files to <code>inputs/sgc_conf</code>, a directory the user will need to make before generating the config files. </p> <pre><code>import yaml\nimport io\nimport pandas as pd\nimport re\n\nm = pd.read_csv(\"metadata.tsv\", header = 0)\nSAMPLES = m['sample_name'].unique().tolist()\n\ngenome_queries = genomes = [\"ERS235530_10.fna.gz\", \"ERS235531_43.fna.gz\", \"ERS235603_16.fna.gz\"]\ngenome_query_paths = [\"inputs/queries/\" + genome for genome in genome_queries]\n\nfor sample in SAMPLES:\n    yml = {'catlas_base': sample,\n           'input_sequences': ['outputs/abundtrim/' + sample + '.abundtrim.fq.gz'],\n           'ksize': 31, \n           'radius': 1,\n           'search': genome_query_paths}\n    with io.open(\"inputs/sgc_conf/\" + sample + '_r1_conf.yml', 'w', encoding='utf8') as outfile:\n        yaml.dump(yml, outfile, default_flow_style=False, allow_unicode=True, sort_keys=False)\n</code></pre>"},{"location":"06-snakemake-spacegraphcats/#using-snakemake-to-automatically-generate-configuration-files","title":"Using snakemake to automatically generate configuration files","text":"<p>In some workflows, the queries may not be pre-defined but instead may be first produced by the workflow. In this case, snakemake checkpoints can be used to automatically and flexibly generate spacegraphcats configuration files based on the results of the workflow.</p> <p>The genome-grist pipeline implements this strategy based on the output of <code>sourmash gather</code>.  When run against a metagenome, <code>gather</code> compares the metagenome against a database of genomes and returns the minimum set of genomes that will produce the maximum mapped reads. One output of <code>gather</code> is a csv file that specifies genomes that are contained in a metagenome. These genomes make a great set of spacegraphcats queries, but will be unknown until <code>sourmash gather</code> has been run on the metagenome by the workflow. </p>"},{"location":"0a-primer/","title":"Primer on metagenome analysis methods and spacegraphcats","text":"<p>A metagenome is DNA sequencing data derived from a collection of genomes in a community. Both short and long read sequencing chemistries can be used to sequence a metagenome. Currently, short reads generally capture more diversity in a community but are difficult to reconstruct into population-level genomes. In contrast, long reads contain longer contiguous sequences but fail to capture diversity of sequences in a community. </p>"},{"location":"0a-primer/#analysis-options-for-metagenome-samples","title":"Analysis options for metagenome samples","text":"<p>To get more information out of a metagenomics sample, there are five common approaches.</p> <ol> <li>De novo assemble and bin the reads into metagenome assembled genomes. de novo assembly and binning are reference-free approaches to produce metagenome-assembled genomes (bins) from metagenome reads. de novo assembly works by finding overlaps between reads and assembling them into larger \"contiguous sequences\" (usually shortened to contigs). Depending on the depth, coverage, and biological properties of a sample, these contigs range in size from 500 base pairs to hundreds of thousands of base pairs. These assemblies can then be binned into metagenome-assembled genomes.  Most binners use tetranucleotide frequency and abundance information to bin contigs. A tetranucleotide is a 4 base pair sequence within a genome. Almost all tetranucleotides occur in almost all genomes, however the frequency that they occur in a given genome is usually conserved (see here). So, binners exploit this information and calculate tetranucleotide frequency for all contigs in an assembly, and group the contigs together that have similar frequencies. This is also coupled with abundance information; if two contigs belong together, they probably have the same abundance because they came from the same organism in a sample. These approaches allow researchers to ask questions about the genomes of organisms in metagenomes even if there is no reference that has been sequenced before. For this reason, they are both very popular and very powerful. However, both assembly and binning suffer from biases that lead to incomplete results. Assembly fails when either 1) an area does not have enough reads to cover the region (low coverage) and 2) when the region is too complicated and there are too many viable combinations of sequences so the assembler doesn't know how to make a decision. This second scenario can occur when there are a lot of errors in the reads, or when there is a lot of strain variation in a genome.  In either case, the assembly breaks and outputs fragmented contigs, or no contigs at all. Although tetranucleotide frequency and abundance information are strong signals, tetranucleotide frequency can only be reliably estimated on contigs that are &gt;2000 base pairs. Because many things fail to assemble to that length, they are not binned. </li> </ol> <p> The bottom graph panel shows % read mapping rate for metagenomes from two different envrionments when different de novo assemblers are used. Many reads are not assembled, oftening leaving this fraction of the metagenome unanalyzed. Source Vollmers et al. 2017.</p> <ol> <li>Map reads to reference genomes With advances in culturomics and de novo metagenome analysis, reference databases contain hundreds of thousands of microbial genome sequences.  By mapping metagenome reads against these databases, you can use reference genomes to ascertain the taxonomic and functional profile of a metagenome sample.  However, metagenome reads that do not closely match any known reference go unanalyzed with reference-based approaches. </li> </ol> <p> Figure panel A shows the percent of reads in metagenomes from different environments that are not classifiable by different tools because sequences are not present in the database. Source Tamames et al. 2019</p> <ol> <li>Gene-level analysis Often times, many more contigs will assemble than will bin.  In cases like this, it's possible to do a gene-level analysis of a metagenome where you annotate open reading frames (ORFs) on the assembled contigs. This type of analysis can give you an idea of the functional potential in our metagenome.</li> <li>Read-level analysis There are many tools that work directly on metagenome reads to estimate taxonomy or function (e.g. gene identity). These tools include Kraken and mifaser. </li> <li>Use assembly graphs ([compact] de Bruijn graphs) to rescue unassembled and unbinned reads that are not in reference databases, and analyze these reads Assembly graphs contain all of the sequences that are contained in the reads.  Using assembly graphs, it is possible to access and analyze unassembled and unbinned reads that have not been previously deposited in a reference database. Many tools facilitate assembly graph analysis, including the assembly graph builder BCALM and the assembly graph visualizer Bandage. Spacegraphcats introduces a computationally efficient framework for organizing and querying assembly graphs at scale.</li> </ol> <p>Below we introduce the concept of assembly graphs and their utility in metagenome analysis.</p>"},{"location":"0a-primer/#representing-all-the-k-mers-de-bruijn-graphs-and-compact-de-bruijn-graphs","title":"Representing all the k-mers: de Bruijn graphs and compact de Bruijn graphs","text":"<p>In real life, DNA sequences are fully contiguous within a genome (or chromosome). When a genome is chopped up into little pieces for sequencing, connectivity information is lost. In order to get this connectivity information back to create an assembly, assemblers use different strategies to identify overlapping sequences among reads.</p> <p> Figure from Ayling et al. 2020 (https://doi.org/10.1093/bib/bbz020) depicting two strategies commonly used by assemblers.</p> <p>A de Bruijn graph is one way to represent this information. A de Bruijn graph is built by breaking sequencing data down into k-mers and finding all overlaps of size k-1 between all k-mers. The figure above below demonstrates this process. Each node in the graph represents a k-mer (here of size 3), and each arrow represents an overlap between two k-mer by k-1 nucleotides (here, by 2 nucleotides). Each k-mer only occurs in the graph once.</p> <p>A compact de Bruijn graph (cDBG) is built from the de Bruijn graph by collapsing all linear paths of k-mers into a single node. While all the nodes in this graph happen to be the same length, nodes in a cDBG usually vary in size. Every k-mer still only occurs once in the graph, but now nodes grow in size to be greater than k. Annecdotally, nodes in a metagenome cDBG range from k to ~2000 nucleotides when k = 31.</p> <p> de Bruijn graph collapsed to a compact de Bruijn graph.</p> <p>Both DBGs and cDBGs contain every k-mer from a sample.</p>"},{"location":"0a-primer/#assembly-graphs-in-the-wild","title":"Assembly graphs in the wild","text":"<p>Real metagenome assembly graphs are complex. Below is an assembly graph from a mouse gut metagenome by @SilasKieser.  Many metagenome graphs are fully connected (e.g. have a single component), and are large and complex.</p> <p> An assembly graph of a mouse gut metagenome. The assembly graph was built by metaspades and visualized with Bandage. Image courtesy of Silas Kieser.</p>"},{"location":"0a-primer/#sequence-context-in-a-cdbg","title":"Sequence context in a cDBG","text":"<p>Depending on how a graph is built, nodes within a graph may be arranged so that sequences that were contiguous within a genome are co-located. The figure below depicts an assembly graph from five metagenomes sequenced from bacterial communities that feed on percholate (see the original blog post here). In this assembly graph, sequences that were binned together appear in the same color, showing that sequences that orginate from the same genome (or from closely related genomes) are connected within the assembly graph.</p> <p> A combined assembly graph from 5 metagenomes sequenced from percholate-feeding bacterial communities. Each of the 48 bins is one of 12 colors, every color is used 4 times. Unbinned sequences are in gray. Source here.</p> <p>While assembly graphs organize sequences from closely related genomes on a macro scale within the graph, there is also ~gene level organization at a smaller scale. In the two figures below, genes that have high sequence similarity in multiple genes overlap in the graph.  On either side of the gene sequence itself, different genome sequences branch off.   </p> <p> In figure panel A, gene pcrA is collapsed within the assembly graph. Source Barnum et al. 2018.</p> <p> A portion of an assembly graph depicting antibiotic resistance gene cfxA3. The gene is surrounded by multiple species, indicating that this gene likely occurred in each of these genomes. Source Olekhnovih et al. 2018</p>"},{"location":"0a-primer/#approaches-for-analyzing-assembly-graphs","title":"Approaches for analyzing assembly graphs","text":"<p>As outlined above, many reads do not match known references, don't assemble, and/or don't bin.  Because these sequences are in the assembly graph, they can still be accessed and analyzed. Below we discuss three approaches for analyzing sequences in assembly graphs.</p>"},{"location":"0a-primer/#building-an-assembly-graph-and-blasting-against-it-to-identify-regions-of-interest","title":"Building an assembly graph and BLASTing against it to identify regions of interest","text":"<p>Many tools can be used to build an assembly graph (e.g. BCALM, metaspades).  Then, the assembly graph can be visualized with the tool Bandage.  Bandage allows users to BLAST the assembly graph, revealing the context of sequences within the graph. See Barnum et al. 2018 for an example of this workflow. This approach is great, but time consuming and difficult to automate. </p>"},{"location":"0a-primer/#identifying-antimicrobial-resistance-genes-and-their-assembly-graph-context-with-metacherchant","title":"Identifying antimicrobial resistance genes and their assembly graph context with MetaCherchant","text":"<p>Metacherchant automates the identification of antimicrobial resistance genes and their context in metagenomes.  See Olekhnovich et al. 2018 for a description of this tool.</p>"},{"location":"0a-primer/#querying-an-assembly-graph-with-spacegraphcats","title":"Querying an assembly graph with spacegraphcats","text":"<p>Spacegraphcats uses a novel data structure to represent the cDBG with less complexity while maintaining biological relationships between the sequences.  It then uses novel algorithms that exploit properties of the cDBG to quickly query into the data structure.</p> <p>To visualize this, look the figure below depicting a cDBG of an Escherichia coli genome + errors  (this is an isolate, so the errors simulate strain variation in a real metagenome community.  It's a rough approximation that works well for visualizing what spacegraphcats does under the hood).  On the left is the cDBG, and on the right is the simplified structure produced by spacegraphcats. The structure on the right is simplified so its faster to query into.</p> <p> Escherichia coli compact de Bruign graph and spacegraphcats catlas.</p> <p>Spacegraphcats queries work by decomposing the query into k-mers, finding the node in which a query k-mer is contained within the spacegraphcats graph, and returning all of the k-mers in that node.  This process is efficient enough to work on the whole metagenome for every k-mer in the query.</p>"},{"location":"calculating-taxonomic-purity/","title":"Calculating taxonomic purity of extracted bins","text":"<p>This is documentation on how to use <code>scripts/tax-classify.py</code> to estimate the taxonomic purity of bins of k-mers.</p>"},{"location":"calculating-taxonomic-purity/#getting-set-up","title":"Getting set up.","text":"<p>First, we'll need an LCA database, which combines signatures with taxonomic information; the command sourmash lca index builds such a database.</p> <p>For this we need two things:</p> <ul> <li>a bunch of signatures, with names;</li> <li>the taxonomic information for those signatures, calculated e.g. by dib-lab/2018-ncbi-lineages;</li> </ul> <p>For the podar data set, the taxonomic lineages are here: spacegraphcats/data/podar-lineages.csv</p> <p>To calculate the signatures for the podar data set, we should use a lower scaled value, which will give higher resolution to the taxonomic classification:</p> <pre><code>sourmash compute -k 31 --scaled=100 {?,??}.fa -f --name-from-first\n</code></pre> <p>Then, to calculate an LCA database, do:</p> <pre><code>sourmash lca index podar-lineage.csv podar-ref.scaled100.lca.json \\\n    {?,??}.fa.sig \\\n    --scaled 100 -C 3 --split-identifiers\n</code></pre> <p>This will result in a file <code>podar-ref.scaled100.lca.json</code> that you can use with <code>tax-classify.py</code>.</p>"},{"location":"calculating-taxonomic-purity/#running-tax-classify-on-catlas-region-output","title":"Running tax-classify on catlas region output","text":"<p>First, generate the <code>.node_mh</code> file from a catlas with the appropriate scaled value; it should be no smaller than the one used when computing the signatures &amp; building the LCA database, above.</p> <pre><code>python -m search.characterize_catlas_regions twofoo_k31_r1 twofoo.vec --scaled=100\n</code></pre> <p>Then:</p> <pre><code>scripts/tax-classify.py twofoo.vec podar-ref.scaled100.lca.json\n</code></pre>"},{"location":"calculating-taxonomic-purity/#running-tax-classify-sigs-on-catlas-search-output","title":"Running tax-classify-sigs on catlas search output","text":"<p>You can run the same code as in <code>tax-classify.py</code> on signatures produced by <code>search.extract_nodes_by_query</code>, using a different front-end script:</p> <pre><code>scripts/tax-classify-sigs.py ./podarV_k31_r1_search_oh0_jan19/[012].fa.contigs.sig \\\n    ~/dev/sourmash/podar-ref.1k.lca.json \n</code></pre> <p>Here, the output is more detailed because we expect more of these bins to be low purity.</p>"},{"location":"developing-spacegraphcats/","title":"spacegraphcats: a brief developer guide","text":"<p>Spacegraphcats is written as a snakemake pipeline. The DAG below gives an overview of the steps in the pipeline and the scripts that execute them.</p> <p></p> <p>The spacegraphcats command line interface uses the click API. This also allows any snakemake flag to be added to the spacegraphcats CLI (e.g. <code>--unlock</code>).</p>"},{"location":"developing-spacegraphcats/#spacegraphcats-files-and-what-scripts-produce-them","title":"spacegraphcats files and what scripts produce them","text":"<ul> <li>the <code>dory_k21/</code> directory contains the various cDBG files<ul> <li><code>bcalm.inputlist.txt</code></li> <li><code>bcalm.unitigs.fa</code></li> <li><code>bcalm.unitigs.pickle</code></li> <li><code>bcalm.unitigs.db</code> - database of unitigs in the cDBG. A FASTA file can be produced from this file by running <code>python -m spacegraphcats.cdbg.dump_contigs_db_to_fasta dory_k21/bcalm.unitigs.db</code>. </li> <li><code>bcalm.unitigs.fa.sig</code> - sourmash signature for the cDBG nodes. Defaults to scaled = 1000. </li> </ul> </li> <li>the <code>dory_k21_r1/</code> directory contains the various files of the catlas constructed by spacegraphcats:<ul> <li>cdbg.gxt - the cDBG connection graph, in a custom format; produced by <code>bcalm_to_gxt.py</code></li> <li>reads.bgz.index - a BGZF file containing the cDBG unitigs; produced by <code>bcalm_to_gxt.py</code></li> <li>contigs.info.csv - summary information about the cDBG unitigs; produced by <code>bcalm_to_gxt.py</code></li> <li>contigs.indices - a numpy savez file containing mapping arrays; produced by <code>index_contigs_by_kmer.py</code></li> <li>contigs.mphf - Minimal Perfect Hash Function parameters for all of the k-mers in the cDBG; produced by <code>index_contigs_by_kmer.py</code></li> <li>contigs.sig - sourmash signature for cDBG nodes. Defaults to scaled = 1000. </li> <li>contigs.sizes - sizes of all cDBG nodes in pickle format; produced by <code>index_cdbg_by_kmer.py</code></li> <li>first_doms.txt - the dominating set information for the cDBG; produced by <code>spacegraphcats.catlas.catlas</code></li> <li>catlas.csv - the catlas for the cDBG; produced by <code>spacegraphcats.catlas.catlas</code></li> <li>commands.log - a partial log of all of the commands</li> </ul> </li> <li>the <code>dory_k21_r1_search_oh0/</code> directory contains the output of a search:<ul> <li>results.csv - summary results for the queries (containment, similarity, etc.)</li> <li>dory-head.fa.cdbg_ids.txt.gz - cDBG node IDs (unitig IDs) matching query</li> <li>dory-head.fa.cdbg_ids.reads.gz - if <code>extract_reads</code> is used, reads from the original sequencing file that contain k-mers in the query neighborhood contigs </li> <li>dory-head.fa.contigs.sig - the sourmash signature of the entire match in the cDBG</li> <li>dory-head.fa.frontier.txt.gz - catlas node IDs matching query</li> <li>dory-head.fa.response.txt - response curve showing how much overhead is gained for each node</li> <li>command.txt - a partial log of the commands run</li> </ul> </li> </ul>"},{"location":"developing-spacegraphcats/#spacegraphcats-internal-commands","title":"Spacegraphcats internal commands","text":"<p>For a brief look at some internal commands, see this slideshow.</p>"},{"location":"developing-spacegraphcats/#extract_readspy-going-from-k-mer-to-cdbgunitig-id-to-read","title":"<code>extract_reads.py</code>: going from k-mer to cDBG/unitig ID to read","text":"<p>Spacegraphcats optionally outputs the reads that contain k-mers in a neighborhood.  This requires being able to go from k-mer to cDBG unitig to read.  Below we describe how is this implemented. The code for that retrieval is in extract_reads.py.</p> <p>First, we put all of the reads in a BGZF file, which is a gzipped file that can be accessed by position.  This lets us retrieve reads based solely on an offset into that file.  See make_bgzf.py and bgzf/ for our copy of the BGZF indexing code, taken from BioPython.</p> <p>Then, we build a table that connects query k-mers to cDBG unitig IDs.  Here the offset in the table is the MPHF of the query k-mer, built using bbhash, and the value in the table is the number of the cDBG unitig.  This connects with internal spacegraphcats stuff.</p> <p>Last but not least, we build a sqlite unitig-to-read offset table in index_cdbg_by_kmer.py.  This is a multimap table (read, unitig ID) that lets us query for the BGZF offset for all reads that belong to a given unitig ID.  Once we have the read offsets for a given unitig ID, using the bgzf code we can reach into a sequence file and retrieve the relevant read(s) directly. </p>"},{"location":"developing-spacegraphcats/#test-data-sets","title":"Test data sets","text":"<p>We use two test data sets, <code>dory</code> and <code>twofoo</code>.  These data sets are packaged in the github repo under <code>tests/test-data</code>. Dory is a subset of contigs from a Doryteuthis RNAseq assembly and is the smallest test set at 300KB.  For a full example workflow using this data set, see the repository spacegraphcats-dory-example.</p> <p>Twofoo is a subset of reads from a synthetic metagenome sequenced by Shakya et al., 2013. The metagenome was constructed by aliquoting isolate DNA into a mixture and sequencing this mixture. We often refer to this metagenom as \"podar\", the last name of the senior author on the Shakya et al. 2013 paper. The test data is composed of two sets of reads, <code>shew-reads</code> and <code>akker-reads</code>. <code>shew-reads.abundtrim.gz</code> is a collection of reads from podar data that maps to the Shewanella OS223 genome via <code>bwa aln</code>. Note that there is significant overlap with the Shewanella baltica OS185 genome; meaning these reads have significant strain variation. <code>akker-reads.abundtrim.gz</code> is a collection of reads from podar that maps to Akkermansia muciniphila ATCC BAA-835 via <code>bwa aln</code>. The <code>akker-reads</code> do not have strain variation. For a full example workflow using this data set, see the repository spacegraphcats-twofoo-example.</p>"}]}